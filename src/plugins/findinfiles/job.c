/* job.c generated by valac 0.32.0.61-f103e, the Vala compiler
 * generated from job.vala, do not modify */

/*
* Copyright (C) 2015 The Lemon Man
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*/

#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <stdlib.h>
#include <gio/gio.h>
#include <gedit/gedit-utils.h>
#include <glib/gstdio.h>
#include <gobject/gvaluecollector.h>


#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER (gedit_find_in_files_plugin_imatcher_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_IMATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER, GeditFindInFilesPluginIMatcher))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_IMATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER))
#define GEDIT_FIND_IN_FILES_PLUGIN_IMATCHER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER, GeditFindInFilesPluginIMatcherIface))

typedef struct _GeditFindInFilesPluginIMatcher GeditFindInFilesPluginIMatcher;
typedef struct _GeditFindInFilesPluginIMatcherIface GeditFindInFilesPluginIMatcherIface;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_RANGE (gedit_find_in_files_plugin_range_get_type ())
typedef struct _GeditFindInFilesPluginRange GeditFindInFilesPluginRange;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOOKMARK (gedit_find_in_files_plugin_bookmark_get_type ())
typedef struct _GeditFindInFilesPluginBookmark GeditFindInFilesPluginBookmark;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_RESULT (gedit_find_in_files_plugin_result_get_type ())
typedef struct _GeditFindInFilesPluginResult GeditFindInFilesPluginResult;
#define _g_free0(var) (var = (g_free (var), NULL))

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB (gedit_find_in_files_plugin_find_job_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJob))
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJobClass))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_FIND_JOB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_FIND_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB))
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJobClass))

typedef struct _GeditFindInFilesPluginFindJob GeditFindInFilesPluginFindJob;
typedef struct _GeditFindInFilesPluginFindJobClass GeditFindInFilesPluginFindJobClass;
typedef struct _GeditFindInFilesPluginFindJobPrivate GeditFindInFilesPluginFindJobPrivate;
#define _g_async_queue_unref0(var) ((var == NULL) ? NULL : (var = (g_async_queue_unref (var), NULL)))
#define __g_list_free__g_thread_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_thread_unref0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND (gedit_find_in_files_plugin_regex_find_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_REGEX_FIND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND, GeditFindInFilesPluginRegexFind))
#define GEDIT_FIND_IN_FILES_PLUGIN_REGEX_FIND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND, GeditFindInFilesPluginRegexFindClass))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_REGEX_FIND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_REGEX_FIND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND))
#define GEDIT_FIND_IN_FILES_PLUGIN_REGEX_FIND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND, GeditFindInFilesPluginRegexFindClass))

typedef struct _GeditFindInFilesPluginRegexFind GeditFindInFilesPluginRegexFind;
typedef struct _GeditFindInFilesPluginRegexFindClass GeditFindInFilesPluginRegexFindClass;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL (gedit_find_in_files_plugin_boyer_moore_horspool_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_BOYER_MOORE_HORSPOOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL, GeditFindInFilesPluginBoyerMooreHorspool))
#define GEDIT_FIND_IN_FILES_PLUGIN_BOYER_MOORE_HORSPOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL, GeditFindInFilesPluginBoyerMooreHorspoolClass))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_BOYER_MOORE_HORSPOOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_BOYER_MOORE_HORSPOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL))
#define GEDIT_FIND_IN_FILES_PLUGIN_BOYER_MOORE_HORSPOOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL, GeditFindInFilesPluginBoyerMooreHorspoolClass))

typedef struct _GeditFindInFilesPluginBoyerMooreHorspool GeditFindInFilesPluginBoyerMooreHorspool;
typedef struct _GeditFindInFilesPluginBoyerMooreHorspoolClass GeditFindInFilesPluginBoyerMooreHorspoolClass;
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
#define _gedit_find_in_files_plugin_find_job_unref0(var) ((var == NULL) ? NULL : (var = (gedit_find_in_files_plugin_find_job_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define __g_queue_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_queue_free__g_object_unref0_ (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _GeditFindInFilesPluginFindJobExecuteData GeditFindInFilesPluginFindJobExecuteData;
#define _g_mapped_file_unref0(var) ((var == NULL) ? NULL : (var = (g_mapped_file_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _GeditFindInFilesPluginParamSpecFindJob GeditFindInFilesPluginParamSpecFindJob;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeditFindInFilesPluginRange {
	gsize from;
	gsize to;
};

struct _GeditFindInFilesPluginIMatcherIface {
	GTypeInterface parent_iface;
	gboolean (*has_match) (GeditFindInFilesPluginIMatcher* self, guint8* text, gsize text_length, gsize pos, GeditFindInFilesPluginRange* match);
};

struct _GeditFindInFilesPluginBookmark {
	gint line_number;
	gsize line_start;
	gsize line_length;
};

struct _GeditFindInFilesPluginResult {
	gchar* path;
	gsize line;
	gchar* context;
};

struct _GeditFindInFilesPluginFindJob {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeditFindInFilesPluginFindJobPrivate * priv;
	gboolean include_hidden;
	gboolean match_whole_word;
	gboolean ignore_case;
};

struct _GeditFindInFilesPluginFindJobClass {
	GTypeClass parent_class;
	void (*finalize) (GeditFindInFilesPluginFindJob *self);
};

struct _GeditFindInFilesPluginFindJobPrivate {
	GAsyncQueue* scan_queue;
	GList* thread_workers;
	guint running_workers;
	GRecMutex __lock_running_workers;
	GeditFindInFilesPluginIMatcher* matcher;
	GCancellable* cancellable;
	gchar* _needle;
};

struct _GeditFindInFilesPluginFindJobExecuteData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	GeditFindInFilesPluginFindJob* self;
	gchar* root;
	GQueue* queue;
	GQueue* _tmp0_;
	GHashTable* visited;
	GHashFunc _tmp1_;
	GEqualFunc _tmp2_;
	GHashTable* _tmp3_;
	GQueue* _tmp4_;
	const gchar* _tmp5_;
	GFile* _tmp6_;
	GQueue* _tmp7_;
	gboolean _tmp8_;
	GCancellable* _tmp9_;
	gboolean _tmp10_;
	GFile* dir;
	GQueue* _tmp11_;
	gpointer _tmp12_;
	GFileEnumerator* e;
	GFile* _tmp13_;
	GFileEnumerator* _tmp14_;
	GList* files;
	GFileEnumerator* _tmp15_;
	GList* _tmp16_;
	GList* _tmp17_;
	GCancellable* _tmp18_;
	gboolean _tmp19_;
	GList* _tmp20_;
	GList* file_collection;
	GList* file_it;
	GFileInfo* _tmp21_;
	GFileInfo* file;
	gboolean _tmp22_;
	gboolean _tmp23_;
	GFileInfo* _tmp24_;
	const gchar* _tmp25_;
	gchar _tmp26_;
	GFileInfo* _tmp27_;
	gboolean _tmp28_;
	GFile* _file;
	GFile* _tmp29_;
	GFileInfo* _tmp30_;
	const gchar* _tmp31_;
	GFile* _tmp32_;
	GFileInfo* _tmp33_;
	GFileType _tmp34_;
	GAsyncQueue* _tmp35_;
	GFile* _tmp36_;
	gchar* _tmp37_;
	GQueue* _tmp38_;
	GFile* _tmp39_;
	GFile* _tmp40_;
	GHashTable* _tmp41_;
	GFile* _tmp42_;
	gchar* _tmp43_;
	gchar* link_dest;
	GFile* _tmp44_;
	gchar* _tmp45_;
	gchar* _tmp46_;
	gchar* _tmp47_;
	gchar* _tmp48_;
	gboolean _tmp49_;
	const gchar* _tmp50_;
	GHashTable* _tmp51_;
	const gchar* _tmp52_;
	gboolean _tmp53_;
	gboolean _tmp54_;
	const gchar* _tmp55_;
	gboolean _tmp56_;
	gboolean _tmp57_;
	gboolean _tmp58_;
	const gchar* _tmp59_;
	gchar _tmp60_;
	GQueue* _tmp61_;
	const gchar* _tmp62_;
	GFile* _tmp63_;
	GError * _inner_error_;
};

struct _GeditFindInFilesPluginParamSpecFindJob {
	GParamSpec parent_instance;
};


static GType gedit_find_in_files_plugin_imatcher_type_id = 0;
static gpointer gedit_find_in_files_plugin_find_job_parent_class = NULL;
static GType gedit_find_in_files_plugin_find_job_type_id = 0;

GType gedit_find_in_files_plugin_range_get_type (void) G_GNUC_CONST;
GeditFindInFilesPluginRange* gedit_find_in_files_plugin_range_dup (const GeditFindInFilesPluginRange* self);
void gedit_find_in_files_plugin_range_free (GeditFindInFilesPluginRange* self);
GType gedit_find_in_files_plugin_imatcher_get_type (void) G_GNUC_CONST;
GType gedit_find_in_files_plugin_imatcher_register_type (GTypeModule * module);
gboolean gedit_find_in_files_plugin_imatcher_has_match (GeditFindInFilesPluginIMatcher* self, guint8* text, gsize text_length, gsize pos, GeditFindInFilesPluginRange* match);
GType gedit_find_in_files_plugin_bookmark_get_type (void) G_GNUC_CONST;
GeditFindInFilesPluginBookmark* gedit_find_in_files_plugin_bookmark_dup (const GeditFindInFilesPluginBookmark* self);
void gedit_find_in_files_plugin_bookmark_free (GeditFindInFilesPluginBookmark* self);
GType gedit_find_in_files_plugin_result_get_type (void) G_GNUC_CONST;
GeditFindInFilesPluginResult* gedit_find_in_files_plugin_result_dup (const GeditFindInFilesPluginResult* self);
void gedit_find_in_files_plugin_result_free (GeditFindInFilesPluginResult* self);
void gedit_find_in_files_plugin_result_copy (const GeditFindInFilesPluginResult* self, GeditFindInFilesPluginResult* dest);
void gedit_find_in_files_plugin_result_destroy (GeditFindInFilesPluginResult* self);
gpointer gedit_find_in_files_plugin_find_job_ref (gpointer instance);
void gedit_find_in_files_plugin_find_job_unref (gpointer instance);
GParamSpec* gedit_find_in_files_plugin_param_spec_find_job (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gedit_find_in_files_plugin_value_set_find_job (GValue* value, gpointer v_object);
void gedit_find_in_files_plugin_value_take_find_job (GValue* value, gpointer v_object);
gpointer gedit_find_in_files_plugin_value_get_find_job (const GValue* value);
GType gedit_find_in_files_plugin_find_job_get_type (void) G_GNUC_CONST;
GType gedit_find_in_files_plugin_find_job_register_type (GTypeModule * module);
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJobPrivate))
enum  {
	GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_DUMMY_PROPERTY
};
static void _g_free0_ (gpointer var);
static void _g_thread_unref0_ (gpointer var);
static void _g_list_free__g_thread_unref0_ (GList* self);
static gint gedit_find_in_files_plugin_find_job_worker (GeditFindInFilesPluginFindJob* self);
static void gedit_find_in_files_plugin_find_job_scan_file (GeditFindInFilesPluginFindJob* self, const gchar* path);
static gboolean _____lambda5_ (GeditFindInFilesPluginFindJob* self);
static gboolean ______lambda5__gsource_func (gpointer self);
GeditFindInFilesPluginFindJob* gedit_find_in_files_plugin_find_job_new (GCancellable* cancellable);
GeditFindInFilesPluginFindJob* gedit_find_in_files_plugin_find_job_construct (GType object_type, GCancellable* cancellable);
static void gedit_find_in_files_plugin_find_job_set_needle (GeditFindInFilesPluginFindJob* self, const gchar* value);
void gedit_find_in_files_plugin_find_job_prepare (GeditFindInFilesPluginFindJob* self, const gchar* needle, gboolean is_regex, GError** error);
GType gedit_find_in_files_plugin_regex_find_get_type (void) G_GNUC_CONST;
GType gedit_find_in_files_plugin_regex_find_register_type (GTypeModule * module);
GeditFindInFilesPluginRegexFind* gedit_find_in_files_plugin_regex_find_new (const gchar* pattern, gboolean ignore_case, GError** error);
GeditFindInFilesPluginRegexFind* gedit_find_in_files_plugin_regex_find_construct (GType object_type, const gchar* pattern, gboolean ignore_case, GError** error);
GeditFindInFilesPluginBoyerMooreHorspool* gedit_find_in_files_plugin_boyer_moore_horspool_new (const gchar* pattern_, gboolean ignore_case_);
GeditFindInFilesPluginBoyerMooreHorspool* gedit_find_in_files_plugin_boyer_moore_horspool_construct (GType object_type, const gchar* pattern_, gboolean ignore_case_);
GType gedit_find_in_files_plugin_boyer_moore_horspool_get_type (void) G_GNUC_CONST;
GType gedit_find_in_files_plugin_boyer_moore_horspool_register_type (GTypeModule * module);
static void gedit_find_in_files_plugin_find_job_start_workers_pool (GeditFindInFilesPluginFindJob* self);
static gpointer _gedit_find_in_files_plugin_find_job_worker_gthread_func (gpointer self);
gchar* gedit_find_in_files_plugin_find_job_extract_context (GeditFindInFilesPluginFindJob* self, guint8* buffer, GeditFindInFilesPluginRange* range);
void gedit_find_in_files_plugin_find_job_halt (GeditFindInFilesPluginFindJob* self);
static gboolean gedit_find_in_files_plugin_find_job_is_binary (GeditFindInFilesPluginFindJob* self, guint8* buffer, gsize buffer_size);
static gboolean gedit_find_in_files_plugin_find_job_ignore_vcs_dir (GeditFindInFilesPluginFindJob* self, GFileInfo* file);
static void gedit_find_in_files_plugin_find_job_execute_data_free (gpointer _data);
void gedit_find_in_files_plugin_find_job_execute (GeditFindInFilesPluginFindJob* self, const gchar* root, GAsyncReadyCallback _callback_, gpointer _user_data_);
void gedit_find_in_files_plugin_find_job_execute_finish (GeditFindInFilesPluginFindJob* self, GAsyncResult* _res_, GError** error);
static gboolean gedit_find_in_files_plugin_find_job_execute_co (GeditFindInFilesPluginFindJobExecuteData* _data_);
static void gedit_find_in_files_plugin_find_job_execute_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _g_object_unref0_ (gpointer var);
static void _g_queue_free__g_object_unref0_ (GQueue* self);
static void _g_list_free__g_object_unref0_ (GList* self);
static void gedit_find_in_files_plugin_find_job_get_line (GeditFindInFilesPluginFindJob* self, guint8* buffer, gsize buffer_size, GeditFindInFilesPluginRange* span, GeditFindInFilesPluginBookmark* bookmark);
static gboolean gedit_find_in_files_plugin_find_job_is_word_boundary (GeditFindInFilesPluginFindJob* self, guint8* buf, gsize buf_size, gsize from, gsize to);
const gchar* gedit_find_in_files_plugin_find_job_get_needle (GeditFindInFilesPluginFindJob* self);
static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void gedit_find_in_files_plugin_find_job_finalize (GeditFindInFilesPluginFindJob* obj);

const GeditFindInFilesPluginBookmark GEDIT_FIND_IN_FILES_PLUGIN_BOOKMARK_EmptyBookmark = {0, (gsize) 0};

gboolean gedit_find_in_files_plugin_imatcher_has_match (GeditFindInFilesPluginIMatcher* self, guint8* text, gsize text_length, gsize pos, GeditFindInFilesPluginRange* match) {
	g_return_val_if_fail (self != NULL, FALSE);
	return GEDIT_FIND_IN_FILES_PLUGIN_IMATCHER_GET_INTERFACE (self)->has_match (self, text, text_length, pos, match);
}


static void gedit_find_in_files_plugin_imatcher_base_init (GeditFindInFilesPluginIMatcherIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType gedit_find_in_files_plugin_imatcher_get_type (void) {
	return gedit_find_in_files_plugin_imatcher_type_id;
}


GType gedit_find_in_files_plugin_imatcher_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (GeditFindInFilesPluginIMatcherIface), (GBaseInitFunc) gedit_find_in_files_plugin_imatcher_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	gedit_find_in_files_plugin_imatcher_type_id = g_type_module_register_type (module, G_TYPE_INTERFACE, "GeditFindInFilesPluginIMatcher", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (gedit_find_in_files_plugin_imatcher_type_id, G_TYPE_OBJECT);
	return gedit_find_in_files_plugin_imatcher_type_id;
}


GeditFindInFilesPluginRange* gedit_find_in_files_plugin_range_dup (const GeditFindInFilesPluginRange* self) {
	GeditFindInFilesPluginRange* dup;
	dup = g_new0 (GeditFindInFilesPluginRange, 1);
	memcpy (dup, self, sizeof (GeditFindInFilesPluginRange));
	return dup;
}


void gedit_find_in_files_plugin_range_free (GeditFindInFilesPluginRange* self) {
	g_free (self);
}


GType gedit_find_in_files_plugin_range_get_type (void) {
	static volatile gsize gedit_find_in_files_plugin_range_type_id__volatile = 0;
	if (g_once_init_enter (&gedit_find_in_files_plugin_range_type_id__volatile)) {
		GType gedit_find_in_files_plugin_range_type_id;
		gedit_find_in_files_plugin_range_type_id = g_boxed_type_register_static ("GeditFindInFilesPluginRange", (GBoxedCopyFunc) gedit_find_in_files_plugin_range_dup, (GBoxedFreeFunc) gedit_find_in_files_plugin_range_free);
		g_once_init_leave (&gedit_find_in_files_plugin_range_type_id__volatile, gedit_find_in_files_plugin_range_type_id);
	}
	return gedit_find_in_files_plugin_range_type_id__volatile;
}


GeditFindInFilesPluginBookmark* gedit_find_in_files_plugin_bookmark_dup (const GeditFindInFilesPluginBookmark* self) {
	GeditFindInFilesPluginBookmark* dup;
	dup = g_new0 (GeditFindInFilesPluginBookmark, 1);
	memcpy (dup, self, sizeof (GeditFindInFilesPluginBookmark));
	return dup;
}


void gedit_find_in_files_plugin_bookmark_free (GeditFindInFilesPluginBookmark* self) {
	g_free (self);
}


GType gedit_find_in_files_plugin_bookmark_get_type (void) {
	static volatile gsize gedit_find_in_files_plugin_bookmark_type_id__volatile = 0;
	if (g_once_init_enter (&gedit_find_in_files_plugin_bookmark_type_id__volatile)) {
		GType gedit_find_in_files_plugin_bookmark_type_id;
		gedit_find_in_files_plugin_bookmark_type_id = g_boxed_type_register_static ("GeditFindInFilesPluginBookmark", (GBoxedCopyFunc) gedit_find_in_files_plugin_bookmark_dup, (GBoxedFreeFunc) gedit_find_in_files_plugin_bookmark_free);
		g_once_init_leave (&gedit_find_in_files_plugin_bookmark_type_id__volatile, gedit_find_in_files_plugin_bookmark_type_id);
	}
	return gedit_find_in_files_plugin_bookmark_type_id__volatile;
}


void gedit_find_in_files_plugin_result_copy (const GeditFindInFilesPluginResult* self, GeditFindInFilesPluginResult* dest) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gsize _tmp2_ = 0UL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	_tmp0_ = (*self).path;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).path);
	(*dest).path = _tmp1_;
	_tmp2_ = (*self).line;
	(*dest).line = _tmp2_;
	_tmp3_ = (*self).context;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 ((*dest).context);
	(*dest).context = _tmp4_;
}


void gedit_find_in_files_plugin_result_destroy (GeditFindInFilesPluginResult* self) {
	_g_free0 ((*self).path);
	_g_free0 ((*self).context);
}


GeditFindInFilesPluginResult* gedit_find_in_files_plugin_result_dup (const GeditFindInFilesPluginResult* self) {
	GeditFindInFilesPluginResult* dup;
	dup = g_new0 (GeditFindInFilesPluginResult, 1);
	gedit_find_in_files_plugin_result_copy (self, dup);
	return dup;
}


void gedit_find_in_files_plugin_result_free (GeditFindInFilesPluginResult* self) {
	gedit_find_in_files_plugin_result_destroy (self);
	g_free (self);
}


GType gedit_find_in_files_plugin_result_get_type (void) {
	static volatile gsize gedit_find_in_files_plugin_result_type_id__volatile = 0;
	if (g_once_init_enter (&gedit_find_in_files_plugin_result_type_id__volatile)) {
		GType gedit_find_in_files_plugin_result_type_id;
		gedit_find_in_files_plugin_result_type_id = g_boxed_type_register_static ("GeditFindInFilesPluginResult", (GBoxedCopyFunc) gedit_find_in_files_plugin_result_dup, (GBoxedFreeFunc) gedit_find_in_files_plugin_result_free);
		g_once_init_leave (&gedit_find_in_files_plugin_result_type_id__volatile, gedit_find_in_files_plugin_result_type_id);
	}
	return gedit_find_in_files_plugin_result_type_id__volatile;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_thread_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_thread_unref (var), NULL));
}


static void _g_list_free__g_thread_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_thread_unref0_, NULL);
	g_list_free (self);
}


static gboolean _____lambda5_ (GeditFindInFilesPluginFindJob* self) {
	gboolean result = FALSE;
	g_signal_emit_by_name (self, "on-search-finished");
	result = FALSE;
	return result;
}


static gboolean ______lambda5__gsource_func (gpointer self) {
	gboolean result;
	result = _____lambda5_ ((GeditFindInFilesPluginFindJob*) self);
	return result;
}


static gint gedit_find_in_files_plugin_find_job_worker (GeditFindInFilesPluginFindJob* self) {
	gint result = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	while (TRUE) {
		GTimeVal tv = {0};
		gchar* path = NULL;
		GAsyncQueue* _tmp0_ = NULL;
		gpointer _tmp1_ = NULL;
		GCancellable* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		g_get_current_time (&tv);
		g_time_val_add (&tv, (glong) (1000000 / 2));
		_tmp0_ = self->priv->scan_queue;
		_tmp1_ = g_async_queue_timed_pop (_tmp0_, &tv);
		path = (gchar*) _tmp1_;
		_tmp2_ = self->priv->cancellable;
		_tmp3_ = g_cancellable_is_cancelled (_tmp2_);
		if (_tmp3_) {
			_g_free0 (path);
			break;
		}
		_tmp4_ = path;
		if (_tmp4_ == NULL) {
			_g_free0 (path);
			break;
		}
		_tmp5_ = path;
		gedit_find_in_files_plugin_find_job_scan_file (self, _tmp5_);
		_g_free0 (path);
	}
	{
		guint _tmp6_ = 0U;
		_tmp6_ = self->priv->running_workers;
		g_rec_mutex_lock (&self->priv->__lock_running_workers);
		{
			guint _tmp7_ = 0U;
			guint _tmp8_ = 0U;
			_tmp7_ = self->priv->running_workers;
			self->priv->running_workers = _tmp7_ - 1;
			_tmp8_ = self->priv->running_workers;
			if (((guint) 0) == _tmp8_) {
				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ______lambda5__gsource_func, gedit_find_in_files_plugin_find_job_ref (self), gedit_find_in_files_plugin_find_job_unref);
			}
		}
		__finally1:
		{
			guint _tmp9_ = 0U;
			_tmp9_ = self->priv->running_workers;
			g_rec_mutex_unlock (&self->priv->__lock_running_workers);
		}
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	result = 0;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GeditFindInFilesPluginFindJob* gedit_find_in_files_plugin_find_job_construct (GType object_type, GCancellable* cancellable) {
	GeditFindInFilesPluginFindJob* self = NULL;
	GCancellable* _tmp0_ = NULL;
	GCancellable* _tmp1_ = NULL;
	GCancellable* _tmp2_ = NULL;
	GCancellable* _tmp4_ = NULL;
	self = (GeditFindInFilesPluginFindJob*) g_type_create_instance (object_type);
	_tmp1_ = cancellable;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_tmp0_ = _tmp2_;
	if (_tmp0_ == NULL) {
		GCancellable* _tmp3_ = NULL;
		_tmp3_ = g_cancellable_new ();
		_g_object_unref0 (_tmp0_);
		_tmp0_ = _tmp3_;
	}
	_tmp4_ = _tmp0_;
	_tmp0_ = NULL;
	_g_object_unref0 (self->priv->cancellable);
	self->priv->cancellable = _tmp4_;
	gedit_find_in_files_plugin_find_job_set_needle (self, NULL);
	self->include_hidden = FALSE;
	self->match_whole_word = FALSE;
	self->ignore_case = FALSE;
	_g_object_unref0 (_tmp0_);
	return self;
}


GeditFindInFilesPluginFindJob* gedit_find_in_files_plugin_find_job_new (GCancellable* cancellable) {
	return gedit_find_in_files_plugin_find_job_construct (GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, cancellable);
}


void gedit_find_in_files_plugin_find_job_prepare (GeditFindInFilesPluginFindJob* self, const gchar* needle, gboolean is_regex, GError** error) {
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (needle != NULL);
	_tmp0_ = is_regex;
	if (_tmp0_) {
		GeditFindInFilesPluginRegexFind* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		GeditFindInFilesPluginRegexFind* _tmp4_ = NULL;
		GeditFindInFilesPluginRegexFind* _tmp5_ = NULL;
		_tmp2_ = needle;
		_tmp3_ = self->ignore_case;
		_tmp4_ = gedit_find_in_files_plugin_regex_find_new (_tmp2_, _tmp3_, &_inner_error_);
		_tmp1_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_propagate_error (error, _inner_error_);
			return;
		}
		_tmp5_ = _tmp1_;
		_tmp1_ = NULL;
		_g_object_unref0 (self->priv->matcher);
		self->priv->matcher = (GeditFindInFilesPluginIMatcher*) _tmp5_;
		_g_object_unref0 (_tmp1_);
	} else {
		const gchar* _tmp6_ = NULL;
		gboolean _tmp7_ = FALSE;
		GeditFindInFilesPluginBoyerMooreHorspool* _tmp8_ = NULL;
		_tmp6_ = needle;
		_tmp7_ = self->ignore_case;
		_tmp8_ = gedit_find_in_files_plugin_boyer_moore_horspool_new (_tmp6_, _tmp7_);
		_g_object_unref0 (self->priv->matcher);
		self->priv->matcher = (GeditFindInFilesPluginIMatcher*) _tmp8_;
	}
}


static gpointer _gedit_find_in_files_plugin_find_job_worker_gthread_func (gpointer self) {
	gpointer result;
	result = (gpointer) ((gintptr) gedit_find_in_files_plugin_find_job_worker ((GeditFindInFilesPluginFindJob*) self));
	gedit_find_in_files_plugin_find_job_unref (self);
	return result;
}


static void gedit_find_in_files_plugin_find_job_start_workers_pool (GeditFindInFilesPluginFindJob* self) {
	guint _tmp0_ = 0U;
	guint online_cpus = 0U;
	guint _tmp1_ = 0U;
	guint _tmp10_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->running_workers;
	if (_tmp0_ != ((guint) 0)) {
		return;
	}
	_tmp1_ = g_get_num_processors ();
	online_cpus = _tmp1_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				guint _tmp5_ = 0U;
				gint _tmp6_ = 0;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				GThread* _tmp9_ = NULL;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = online_cpus;
				if (!(((guint) _tmp4_) < _tmp5_)) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = g_strdup_printf ("Worker %d", _tmp6_);
				_tmp8_ = _tmp7_;
				_tmp9_ = g_thread_new (_tmp8_, _gedit_find_in_files_plugin_find_job_worker_gthread_func, gedit_find_in_files_plugin_find_job_ref (self));
				self->priv->thread_workers = g_list_append (self->priv->thread_workers, _tmp9_);
				_g_free0 (_tmp8_);
			}
		}
	}
	_tmp10_ = online_cpus;
	self->priv->running_workers = _tmp10_;
}


gchar* gedit_find_in_files_plugin_find_job_extract_context (GeditFindInFilesPluginFindJob* self, guint8* buffer, GeditFindInFilesPluginRange* range) {
	gchar* result = NULL;
	guint8* slice = NULL;
	GeditFindInFilesPluginRange _tmp0_ = {0};
	gsize _tmp1_ = 0UL;
	GeditFindInFilesPluginRange _tmp2_ = {0};
	gsize _tmp3_ = 0UL;
	guint8* _tmp4_ = NULL;
	guint8* _tmp5_ = NULL;
	GeditFindInFilesPluginRange _tmp6_ = {0};
	gsize _tmp7_ = 0UL;
	GeditFindInFilesPluginRange _tmp8_ = {0};
	gsize _tmp9_ = 0UL;
	GeditFindInFilesPluginRange _tmp10_ = {0};
	gsize _tmp11_ = 0UL;
	gchar* _tmp12_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (range != NULL, NULL);
	_tmp0_ = *range;
	_tmp1_ = _tmp0_.to;
	_tmp2_ = *range;
	_tmp3_ = _tmp2_.from;
	_tmp4_ = g_new0 (guint8, _tmp1_ - _tmp3_);
	slice = _tmp4_;
	_tmp5_ = buffer;
	_tmp6_ = *range;
	_tmp7_ = _tmp6_.from;
	_tmp8_ = *range;
	_tmp9_ = _tmp8_.to;
	_tmp10_ = *range;
	_tmp11_ = _tmp10_.from;
	memcpy (slice, _tmp5_ + _tmp7_, _tmp9_ - _tmp11_);
	_tmp12_ = gedit_utils_make_valid_utf8 ((const gchar*) slice);
	result = _tmp12_;
	return result;
}


static gpointer _g_thread_ref0 (gpointer self) {
	return self ? g_thread_ref (self) : NULL;
}


void gedit_find_in_files_plugin_find_job_halt (GeditFindInFilesPluginFindJob* self) {
	guint _tmp0_ = 0U;
	GCancellable* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->running_workers;
	if (_tmp0_ == ((guint) 0)) {
		return;
	}
	_tmp1_ = self->priv->cancellable;
	g_cancellable_cancel (_tmp1_);
	_tmp2_ = self->priv->thread_workers;
	{
		GList* worker_collection = NULL;
		GList* worker_it = NULL;
		worker_collection = _tmp2_;
		for (worker_it = worker_collection; worker_it != NULL; worker_it = worker_it->next) {
			GThread* _tmp3_ = NULL;
			GThread* worker = NULL;
			_tmp3_ = _g_thread_ref0 ((GThread*) worker_it->data);
			worker = _tmp3_;
			{
				GThread* _tmp4_ = NULL;
				GThread* _tmp5_ = NULL;
				_tmp4_ = worker;
				_tmp5_ = _g_thread_ref0 (_tmp4_);
				g_thread_join (_tmp5_);
				_g_thread_unref0 (worker);
			}
		}
	}
}


static gboolean gedit_find_in_files_plugin_find_job_is_binary (GeditFindInFilesPluginFindJob* self, guint8* buffer, gsize buffer_size) {
	gboolean result = FALSE;
	guint8* _tmp0_ = NULL;
	gsize _tmp1_ = 0UL;
	void* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = buffer;
	_tmp1_ = buffer_size;
	_tmp2_ = memchr (_tmp0_, (gint) '\0', _tmp1_);
	result = _tmp2_ != NULL;
	return result;
}


static gboolean gedit_find_in_files_plugin_find_job_ignore_vcs_dir (GeditFindInFilesPluginFindJob* self, GFileInfo* file) {
	gboolean result = FALSE;
	GFileInfo* _tmp0_ = NULL;
	GFileType _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	_tmp0_ = file;
	_tmp1_ = g_file_info_get_file_type (_tmp0_);
	if (_tmp1_ == G_FILE_TYPE_DIRECTORY) {
		gchar* name = NULL;
		GFileInfo* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		gboolean _tmp7_ = FALSE;
		gboolean _tmp8_ = FALSE;
		const gchar* _tmp9_ = NULL;
		_tmp2_ = file;
		_tmp3_ = g_file_info_get_name (_tmp2_);
		_tmp4_ = g_strdup (_tmp3_);
		name = _tmp4_;
		_tmp9_ = name;
		if (g_strcmp0 (_tmp9_, ".git") == 0) {
			_tmp8_ = TRUE;
		} else {
			const gchar* _tmp10_ = NULL;
			_tmp10_ = name;
			_tmp8_ = g_strcmp0 (_tmp10_, ".bzr") == 0;
		}
		if (_tmp8_) {
			_tmp7_ = TRUE;
		} else {
			const gchar* _tmp11_ = NULL;
			_tmp11_ = name;
			_tmp7_ = g_strcmp0 (_tmp11_, ".svn") == 0;
		}
		if (_tmp7_) {
			_tmp6_ = TRUE;
		} else {
			const gchar* _tmp12_ = NULL;
			_tmp12_ = name;
			_tmp6_ = g_strcmp0 (_tmp12_, ".hg") == 0;
		}
		if (_tmp6_) {
			_tmp5_ = TRUE;
		} else {
			const gchar* _tmp13_ = NULL;
			_tmp13_ = name;
			_tmp5_ = g_strcmp0 (_tmp13_, "_darcs") == 0;
		}
		if (_tmp5_) {
			result = TRUE;
			_g_free0 (name);
			return result;
		}
		_g_free0 (name);
	}
	result = FALSE;
	return result;
}


static void gedit_find_in_files_plugin_find_job_execute_data_free (gpointer _data) {
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	_data_ = _data;
	_g_free0 (_data_->root);
	_gedit_find_in_files_plugin_find_job_unref0 (_data_->self);
	g_slice_free (GeditFindInFilesPluginFindJobExecuteData, _data_);
}


static gpointer _gedit_find_in_files_plugin_find_job_ref0 (gpointer self) {
	return self ? gedit_find_in_files_plugin_find_job_ref (self) : NULL;
}


void gedit_find_in_files_plugin_find_job_execute (GeditFindInFilesPluginFindJob* self, const gchar* root, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	GeditFindInFilesPluginFindJob* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	_data_ = g_slice_new0 (GeditFindInFilesPluginFindJobExecuteData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, gedit_find_in_files_plugin_find_job_execute);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, gedit_find_in_files_plugin_find_job_execute_data_free);
	_tmp0_ = _gedit_find_in_files_plugin_find_job_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = root;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (_data_->root);
	_data_->root = _tmp2_;
	gedit_find_in_files_plugin_find_job_execute_co (_data_);
}


void gedit_find_in_files_plugin_find_job_execute_finish (GeditFindInFilesPluginFindJob* self, GAsyncResult* _res_, GError** error) {
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void gedit_find_in_files_plugin_find_job_execute_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	gedit_find_in_files_plugin_find_job_execute_co (_data_);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_queue_free__g_object_unref0_ (GQueue* self) {
	g_queue_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_queue_free (self);
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static gboolean gedit_find_in_files_plugin_find_job_execute_co (GeditFindInFilesPluginFindJobExecuteData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = g_queue_new ();
	_data_->queue = _data_->_tmp0_;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_str_hash;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = g_str_equal;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = g_hash_table_new_full (_data_->_tmp1_, _data_->_tmp2_, _g_free0_, NULL);
	_data_->visited = _data_->_tmp3_;
	gedit_find_in_files_plugin_find_job_start_workers_pool (_data_->self);
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = _data_->queue;
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = _data_->root;
	_data_->_tmp6_ = NULL;
	_data_->_tmp6_ = g_file_new_for_path (_data_->_tmp5_);
	g_queue_push_tail (_data_->_tmp4_, _data_->_tmp6_);
	while (TRUE) {
		_data_->_tmp7_ = NULL;
		_data_->_tmp7_ = _data_->queue;
		_data_->_tmp8_ = FALSE;
		_data_->_tmp8_ = g_queue_is_empty (_data_->_tmp7_);
		if (!(!_data_->_tmp8_)) {
			break;
		}
		_data_->_tmp9_ = NULL;
		_data_->_tmp9_ = _data_->self->priv->cancellable;
		_data_->_tmp10_ = FALSE;
		_data_->_tmp10_ = g_cancellable_is_cancelled (_data_->_tmp9_);
		if (_data_->_tmp10_) {
			break;
		}
		_data_->_tmp11_ = NULL;
		_data_->_tmp11_ = _data_->queue;
		_data_->_tmp12_ = NULL;
		_data_->_tmp12_ = g_queue_pop_head (_data_->_tmp11_);
		_data_->dir = (GFile*) _data_->_tmp12_;
		_data_->_tmp13_ = NULL;
		_data_->_tmp13_ = _data_->dir;
		_data_->_state_ = 1;
		g_file_enumerate_children_async (_data_->_tmp13_, G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, G_PRIORITY_DEFAULT, NULL, gedit_find_in_files_plugin_find_job_execute_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp14_ = NULL;
		_data_->_tmp14_ = g_file_enumerate_children_finish (_data_->_tmp13_, _data_->_res_, &_data_->_inner_error_);
		_data_->e = _data_->_tmp14_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_g_object_unref0 (_data_->dir);
			_g_hash_table_unref0 (_data_->visited);
			__g_queue_free__g_object_unref0_0 (_data_->queue);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		while (TRUE) {
			_data_->_tmp15_ = NULL;
			_data_->_tmp15_ = _data_->e;
			_data_->_state_ = 2;
			g_file_enumerator_next_files_async (_data_->_tmp15_, 100, G_PRIORITY_DEFAULT, NULL, gedit_find_in_files_plugin_find_job_execute_ready, _data_);
			return FALSE;
			_state_2:
			_data_->_tmp16_ = NULL;
			_data_->_tmp16_ = g_file_enumerator_next_files_finish (_data_->_tmp15_, _data_->_res_, &_data_->_inner_error_);
			_data_->files = _data_->_tmp16_;
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
				g_error_free (_data_->_inner_error_);
				_g_object_unref0 (_data_->e);
				_g_object_unref0 (_data_->dir);
				_g_hash_table_unref0 (_data_->visited);
				__g_queue_free__g_object_unref0_0 (_data_->queue);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_data_->_tmp17_ = NULL;
			_data_->_tmp17_ = _data_->files;
			if (_data_->_tmp17_ == NULL) {
				__g_list_free__g_object_unref0_0 (_data_->files);
				break;
			}
			_data_->_tmp18_ = NULL;
			_data_->_tmp18_ = _data_->self->priv->cancellable;
			_data_->_tmp19_ = FALSE;
			_data_->_tmp19_ = g_cancellable_is_cancelled (_data_->_tmp18_);
			if (_data_->_tmp19_) {
				__g_list_free__g_object_unref0_0 (_data_->files);
				break;
			}
			_data_->_tmp20_ = NULL;
			_data_->_tmp20_ = _data_->files;
			{
				_data_->file_collection = _data_->_tmp20_;
				for (_data_->file_it = _data_->file_collection; _data_->file_it != NULL; _data_->file_it = _data_->file_it->next) {
					_data_->_tmp21_ = NULL;
					_data_->_tmp21_ = _g_object_ref0 ((GFileInfo*) _data_->file_it->data);
					_data_->file = _data_->_tmp21_;
					{
						_data_->_tmp23_ = FALSE;
						_data_->_tmp23_ = _data_->self->include_hidden;
						if (!_data_->_tmp23_) {
							_data_->_tmp24_ = NULL;
							_data_->_tmp24_ = _data_->file;
							_data_->_tmp25_ = NULL;
							_data_->_tmp25_ = g_file_info_get_name (_data_->_tmp24_);
							_data_->_tmp26_ = '\0';
							_data_->_tmp26_ = string_get (_data_->_tmp25_, (glong) 0);
							_data_->_tmp22_ = _data_->_tmp26_ == '.';
						} else {
							_data_->_tmp22_ = FALSE;
						}
						if (_data_->_tmp22_) {
							_g_object_unref0 (_data_->file);
							continue;
						}
						_data_->_tmp27_ = NULL;
						_data_->_tmp27_ = _data_->file;
						_data_->_tmp28_ = FALSE;
						_data_->_tmp28_ = gedit_find_in_files_plugin_find_job_ignore_vcs_dir (_data_->self, _data_->_tmp27_);
						if (_data_->_tmp28_) {
							_g_object_unref0 (_data_->file);
							continue;
						}
						_data_->_tmp29_ = NULL;
						_data_->_tmp29_ = _data_->dir;
						_data_->_tmp30_ = NULL;
						_data_->_tmp30_ = _data_->file;
						_data_->_tmp31_ = NULL;
						_data_->_tmp31_ = g_file_info_get_name (_data_->_tmp30_);
						_data_->_tmp32_ = NULL;
						_data_->_tmp32_ = g_file_resolve_relative_path (_data_->_tmp29_, _data_->_tmp31_);
						_data_->_file = _data_->_tmp32_;
						_data_->_tmp33_ = NULL;
						_data_->_tmp33_ = _data_->file;
						_data_->_tmp34_ = 0;
						_data_->_tmp34_ = g_file_info_get_file_type (_data_->_tmp33_);
						switch (_data_->_tmp34_) {
							case G_FILE_TYPE_REGULAR:
							{
								_data_->_tmp35_ = NULL;
								_data_->_tmp35_ = _data_->self->priv->scan_queue;
								_data_->_tmp36_ = NULL;
								_data_->_tmp36_ = _data_->_file;
								_data_->_tmp37_ = NULL;
								_data_->_tmp37_ = g_file_get_path (_data_->_tmp36_);
								g_async_queue_push (_data_->_tmp35_, _data_->_tmp37_);
								break;
							}
							case G_FILE_TYPE_DIRECTORY:
							{
								_data_->_tmp38_ = NULL;
								_data_->_tmp38_ = _data_->queue;
								_data_->_tmp39_ = NULL;
								_data_->_tmp39_ = _data_->_file;
								_data_->_tmp40_ = NULL;
								_data_->_tmp40_ = _g_object_ref0 (_data_->_tmp39_);
								g_queue_push_tail (_data_->_tmp38_, _data_->_tmp40_);
								_data_->_tmp41_ = NULL;
								_data_->_tmp41_ = _data_->visited;
								_data_->_tmp42_ = NULL;
								_data_->_tmp42_ = _data_->_file;
								_data_->_tmp43_ = NULL;
								_data_->_tmp43_ = g_file_get_path (_data_->_tmp42_);
								g_hash_table_insert (_data_->_tmp41_, _data_->_tmp43_, (gpointer) ((gintptr) TRUE));
								break;
							}
							case G_FILE_TYPE_SYMBOLIC_LINK:
							{
								_data_->_tmp44_ = NULL;
								_data_->_tmp44_ = _data_->_file;
								_data_->_tmp45_ = NULL;
								_data_->_tmp45_ = g_file_get_path (_data_->_tmp44_);
								_data_->_tmp46_ = NULL;
								_data_->_tmp46_ = _data_->_tmp45_;
								_data_->_tmp47_ = NULL;
								_data_->_tmp47_ = realpath (_data_->_tmp46_, NULL);
								_data_->_tmp48_ = NULL;
								_data_->_tmp48_ = _data_->_tmp47_;
								_g_free0 (_data_->_tmp46_);
								_data_->link_dest = _data_->_tmp48_;
								_data_->_tmp50_ = NULL;
								_data_->_tmp50_ = _data_->link_dest;
								if (_data_->_tmp50_ != NULL) {
									_data_->_tmp51_ = NULL;
									_data_->_tmp51_ = _data_->visited;
									_data_->_tmp52_ = NULL;
									_data_->_tmp52_ = _data_->link_dest;
									_data_->_tmp53_ = FALSE;
									_data_->_tmp53_ = g_hash_table_contains (_data_->_tmp51_, _data_->_tmp52_);
									_data_->_tmp49_ = !_data_->_tmp53_;
								} else {
									_data_->_tmp49_ = FALSE;
								}
								if (_data_->_tmp49_) {
									_data_->_tmp55_ = NULL;
									_data_->_tmp55_ = _data_->link_dest;
									_data_->_tmp56_ = FALSE;
									_data_->_tmp56_ = g_file_test (_data_->_tmp55_, G_FILE_TEST_IS_DIR);
									if (_data_->_tmp56_) {
										_data_->_tmp58_ = FALSE;
										_data_->_tmp58_ = _data_->self->ignore_case;
										if (!_data_->_tmp58_) {
											_data_->_tmp59_ = NULL;
											_data_->_tmp59_ = _data_->link_dest;
											_data_->_tmp60_ = '\0';
											_data_->_tmp60_ = string_get (_data_->_tmp59_, (glong) 0);
											_data_->_tmp57_ = _data_->_tmp60_ != '.';
										} else {
											_data_->_tmp57_ = FALSE;
										}
										_data_->_tmp54_ = _data_->_tmp57_;
									} else {
										_data_->_tmp54_ = FALSE;
									}
									if (_data_->_tmp54_) {
										_data_->_tmp61_ = NULL;
										_data_->_tmp61_ = _data_->queue;
										_data_->_tmp62_ = NULL;
										_data_->_tmp62_ = _data_->link_dest;
										_data_->_tmp63_ = NULL;
										_data_->_tmp63_ = g_file_new_for_path (_data_->_tmp62_);
										g_queue_push_tail (_data_->_tmp61_, _data_->_tmp63_);
									}
								}
								_g_free0 (_data_->link_dest);
								break;
							}
							default:
							break;
						}
						_g_object_unref0 (_data_->_file);
						_g_object_unref0 (_data_->file);
					}
				}
			}
			__g_list_free__g_object_unref0_0 (_data_->files);
		}
		_g_object_unref0 (_data_->e);
		_g_object_unref0 (_data_->dir);
	}
	_g_hash_table_unref0 (_data_->visited);
	__g_queue_free__g_object_unref0_0 (_data_->queue);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void gedit_find_in_files_plugin_find_job_get_line (GeditFindInFilesPluginFindJob* self, guint8* buffer, gsize buffer_size, GeditFindInFilesPluginRange* span, GeditFindInFilesPluginBookmark* bookmark) {
	gint line_count = 0;
	GeditFindInFilesPluginBookmark _tmp0_ = {0};
	gint _tmp1_ = 0;
	gsize line_start = 0UL;
	GeditFindInFilesPluginBookmark _tmp2_ = {0};
	gsize _tmp3_ = 0UL;
	guint8* ptr = NULL;
	guint8* _tmp4_ = NULL;
	GeditFindInFilesPluginBookmark _tmp5_ = {0};
	gsize _tmp6_ = 0UL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (span != NULL);
	g_return_if_fail (bookmark != NULL);
	_tmp0_ = *bookmark;
	_tmp1_ = _tmp0_.line_number;
	line_count = _tmp1_;
	_tmp2_ = *bookmark;
	_tmp3_ = _tmp2_.line_start;
	line_start = _tmp3_;
	_tmp4_ = buffer;
	_tmp5_ = *bookmark;
	_tmp6_ = _tmp5_.line_start;
	ptr = _tmp4_ + _tmp6_;
	while (TRUE) {
		guint8* _tmp7_ = NULL;
		guint8* _tmp8_ = NULL;
		gsize _tmp9_ = 0UL;
		guint8* nl = NULL;
		guint8* _tmp10_ = NULL;
		gsize _tmp11_ = 0UL;
		guint8* _tmp12_ = NULL;
		guint8* _tmp13_ = NULL;
		void* _tmp14_ = NULL;
		guint8* _tmp15_ = NULL;
		gsize line_length = 0UL;
		guint8* _tmp19_ = NULL;
		guint8* _tmp20_ = NULL;
		gboolean _tmp21_ = FALSE;
		GeditFindInFilesPluginRange _tmp22_ = {0};
		gsize _tmp23_ = 0UL;
		gsize _tmp24_ = 0UL;
		gint _tmp32_ = 0;
		gsize _tmp33_ = 0UL;
		gsize _tmp34_ = 0UL;
		guint8* _tmp35_ = NULL;
		_tmp7_ = ptr;
		_tmp8_ = buffer;
		_tmp9_ = buffer_size;
		if (!(_tmp7_ < (_tmp8_ + _tmp9_))) {
			break;
		}
		_tmp10_ = ptr;
		_tmp11_ = buffer_size;
		_tmp12_ = ptr;
		_tmp13_ = buffer;
		_tmp14_ = memchr (_tmp10_, (gint) '\n', _tmp11_ - (_tmp12_ - _tmp13_));
		nl = _tmp14_;
		_tmp15_ = nl;
		if (_tmp15_ == NULL) {
			guint8* _tmp16_ = NULL;
			gsize _tmp17_ = 0UL;
			_tmp16_ = buffer;
			_tmp17_ = buffer_size;
			nl = (_tmp16_ + _tmp17_) + 1;
		} else {
			guint8* _tmp18_ = NULL;
			_tmp18_ = nl;
			nl = _tmp18_ + 1;
		}
		_tmp19_ = nl;
		_tmp20_ = ptr;
		line_length = _tmp19_ - _tmp20_;
		_tmp22_ = *span;
		_tmp23_ = _tmp22_.from;
		_tmp24_ = line_start;
		if (_tmp23_ >= _tmp24_) {
			GeditFindInFilesPluginRange _tmp25_ = {0};
			gsize _tmp26_ = 0UL;
			gsize _tmp27_ = 0UL;
			gsize _tmp28_ = 0UL;
			_tmp25_ = *span;
			_tmp26_ = _tmp25_.to;
			_tmp27_ = line_start;
			_tmp28_ = line_length;
			_tmp21_ = _tmp26_ < (_tmp27_ + _tmp28_);
		} else {
			_tmp21_ = FALSE;
		}
		if (_tmp21_) {
			gint _tmp29_ = 0;
			gsize _tmp30_ = 0UL;
			gsize _tmp31_ = 0UL;
			_tmp29_ = line_count;
			(*bookmark).line_number = _tmp29_;
			_tmp30_ = line_start;
			(*bookmark).line_start = _tmp30_;
			_tmp31_ = line_length;
			(*bookmark).line_length = _tmp31_ - 1;
			return;
		}
		_tmp32_ = line_count;
		line_count = _tmp32_ + 1;
		_tmp33_ = line_start;
		_tmp34_ = line_length;
		line_start = _tmp33_ + _tmp34_;
		_tmp35_ = nl;
		ptr = _tmp35_;
	}
	g_assert_not_reached ();
}


static gunichar string_get_char (const gchar* self, glong index) {
	gunichar result = 0U;
	glong _tmp0_ = 0L;
	gunichar _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	result = _tmp1_;
	return result;
}


static gboolean string_get_prev_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	if (0 < _tmp0_) {
		gint _tmp1_ = 0;
		gchar* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gunichar _tmp4_ = 0U;
		_tmp1_ = *index;
		_tmp2_ = g_utf8_prev_char (((gchar*) self) + _tmp1_);
		*index = (gint) (_tmp2_ - ((gchar*) self));
		_tmp3_ = *index;
		_tmp4_ = g_utf8_get_char (((gchar*) self) + _tmp3_);
		_vala_c = _tmp4_;
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		_vala_c = (gunichar) 0;
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


static gboolean string_get_next_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	gunichar _tmp1_ = 0U;
	gunichar _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	_vala_c = _tmp1_;
	_tmp2_ = _vala_c;
	if (_tmp2_ != ((gunichar) 0)) {
		gint _tmp3_ = 0;
		gchar* _tmp4_ = NULL;
		_tmp3_ = *index;
		_tmp4_ = g_utf8_next_char (((gchar*) self) + _tmp3_);
		*index = (gint) (_tmp4_ - ((gchar*) self));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


static gboolean gedit_find_in_files_plugin_find_job_is_word_boundary (GeditFindInFilesPluginFindJob* self, guint8* buf, gsize buf_size, gsize from, gsize to) {
	gboolean result = FALSE;
	gunichar ch = 0U;
	gboolean prev = FALSE;
	gboolean next = FALSE;
	const gchar* str = NULL;
	gboolean _tmp0_ = FALSE;
	gsize _tmp1_ = 0UL;
	gsize _tmp2_ = 0UL;
	gsize _tmp5_ = 0UL;
	gsize _tmp6_ = 0UL;
	gboolean _tmp7_ = FALSE;
	guint8* _tmp8_ = NULL;
	gsize _tmp9_ = 0UL;
	gint start = 0;
	gint end = 0;
	gsize _tmp10_ = 0UL;
	gsize _tmp11_ = 0UL;
	gunichar head = 0U;
	const gchar* _tmp12_ = NULL;
	gunichar _tmp13_ = 0U;
	gboolean _tmp14_ = FALSE;
	gint _tmp15_ = 0;
	gunichar tail = 0U;
	const gchar* _tmp23_ = NULL;
	gint _tmp24_ = 0;
	gunichar _tmp25_ = 0U;
	gboolean _tmp26_ = FALSE;
	gint _tmp27_ = 0;
	gsize _tmp28_ = 0UL;
	gboolean _tmp36_ = FALSE;
	gboolean _tmp37_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = to;
	_tmp2_ = from;
	if (_tmp1_ > _tmp2_) {
		gsize _tmp3_ = 0UL;
		gsize _tmp4_ = 0UL;
		_tmp3_ = to;
		_tmp4_ = buf_size;
		_tmp0_ = _tmp3_ <= _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	_vala_assert (_tmp0_, "to > from && to <= buf_size");
	_tmp5_ = to;
	_tmp6_ = from;
	if ((_tmp5_ - _tmp6_) > ((gsize) G_MAXINT)) {
		result = FALSE;
		return result;
	}
	ch = (gunichar) '\0';
	next = TRUE;
	_tmp7_ = next;
	prev = _tmp7_;
	_tmp8_ = buf;
	_tmp9_ = from;
	str = (const gchar*) (_tmp8_ + _tmp9_);
	start = 0;
	_tmp10_ = to;
	_tmp11_ = from;
	end = (gint) (_tmp10_ - _tmp11_);
	_tmp12_ = str;
	_tmp13_ = string_get_char (_tmp12_, (glong) 0);
	head = _tmp13_;
	_tmp15_ = start;
	if (_tmp15_ > 0) {
		const gchar* _tmp16_ = NULL;
		gunichar _tmp17_ = 0U;
		gboolean _tmp18_ = FALSE;
		_tmp16_ = str;
		_tmp18_ = string_get_prev_char (_tmp16_, &start, &_tmp17_);
		ch = _tmp17_;
		_tmp14_ = _tmp18_;
	} else {
		_tmp14_ = FALSE;
	}
	if (_tmp14_) {
		gunichar _tmp19_ = 0U;
		gboolean _tmp20_ = FALSE;
		gunichar _tmp21_ = 0U;
		gboolean _tmp22_ = FALSE;
		_tmp19_ = head;
		_tmp20_ = g_unichar_isalnum (_tmp19_);
		_tmp21_ = ch;
		_tmp22_ = g_unichar_isalnum (_tmp21_);
		prev = _tmp20_ != _tmp22_;
	}
	_tmp23_ = str;
	_tmp24_ = end;
	_tmp25_ = string_get_char (_tmp23_, (glong) (_tmp24_ - 1));
	tail = _tmp25_;
	_tmp27_ = end;
	_tmp28_ = buf_size;
	if (((gsize) _tmp27_) < _tmp28_) {
		const gchar* _tmp29_ = NULL;
		gunichar _tmp30_ = 0U;
		gboolean _tmp31_ = FALSE;
		_tmp29_ = str;
		_tmp31_ = string_get_next_char (_tmp29_, &end, &_tmp30_);
		ch = _tmp30_;
		_tmp26_ = _tmp31_;
	} else {
		_tmp26_ = FALSE;
	}
	if (_tmp26_) {
		gunichar _tmp32_ = 0U;
		gboolean _tmp33_ = FALSE;
		gunichar _tmp34_ = 0U;
		gboolean _tmp35_ = FALSE;
		_tmp32_ = tail;
		_tmp33_ = g_unichar_isalnum (_tmp32_);
		_tmp34_ = ch;
		_tmp35_ = g_unichar_isalnum (_tmp34_);
		next = _tmp33_ != _tmp35_;
	}
	_tmp37_ = prev;
	if (_tmp37_) {
		gboolean _tmp38_ = FALSE;
		_tmp38_ = next;
		_tmp36_ = _tmp38_;
	} else {
		_tmp36_ = FALSE;
	}
	result = _tmp36_;
	return result;
}


static void gedit_find_in_files_plugin_find_job_scan_file (GeditFindInFilesPluginFindJob* self, const gchar* path) {
	GMappedFile* file = NULL;
	gsize buffer_size = 0UL;
	GMappedFile* _tmp6_ = NULL;
	gsize _tmp7_ = 0UL;
	guint8* buffer = NULL;
	GMappedFile* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	guint8* _tmp10_ = NULL;
	gsize _tmp11_ = 0UL;
	gboolean _tmp12_ = FALSE;
	GeditFindInFilesPluginRange match = {0};
	GeditFindInFilesPluginRange _tmp13_ = {0};
	GeditFindInFilesPluginBookmark bookmark = {0};
	gint last_line = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	{
		GMappedFile* _tmp0_ = NULL;
		const gchar* _tmp1_ = NULL;
		GMappedFile* _tmp2_ = NULL;
		GMappedFile* _tmp3_ = NULL;
		_tmp1_ = path;
		_tmp2_ = g_mapped_file_new (_tmp1_, FALSE, &_inner_error_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch2_g_file_error;
			}
			_g_mapped_file_unref0 (file);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp3_ = _tmp0_;
		_tmp0_ = NULL;
		_g_mapped_file_unref0 (file);
		file = _tmp3_;
		_g_mapped_file_unref0 (_tmp0_);
	}
	goto __finally2;
	__catch2_g_file_error:
	{
		GError* err = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = err;
		_tmp5_ = _tmp4_->message;
		g_warning ("job.vala:314: %s", _tmp5_);
		_g_error_free0 (err);
		_g_mapped_file_unref0 (file);
		return;
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_mapped_file_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp6_ = file;
	_tmp7_ = g_mapped_file_get_length (_tmp6_);
	buffer_size = _tmp7_;
	_tmp8_ = file;
	_tmp9_ = g_mapped_file_get_contents (_tmp8_);
	buffer = (guint8*) _tmp9_;
	_tmp10_ = buffer;
	_tmp11_ = buffer_size;
	_tmp12_ = gedit_find_in_files_plugin_find_job_is_binary (self, _tmp10_, _tmp11_);
	if (_tmp12_) {
		_g_mapped_file_unref0 (file);
		return;
	}
	_tmp13_.from = (gsize) 0;
	_tmp13_.to = (gsize) 0;
	match = _tmp13_;
	bookmark = GEDIT_FIND_IN_FILES_PLUGIN_BOOKMARK_EmptyBookmark;
	last_line = -1;
	{
		gsize buffer_pos = 0UL;
		buffer_pos = (gsize) 0;
		{
			gboolean _tmp14_ = FALSE;
			_tmp14_ = TRUE;
			while (TRUE) {
				gsize _tmp15_ = 0UL;
				gsize _tmp16_ = 0UL;
				GCancellable* _tmp17_ = NULL;
				gboolean _tmp18_ = FALSE;
				GeditFindInFilesPluginIMatcher* _tmp19_ = NULL;
				guint8* _tmp20_ = NULL;
				gsize _tmp21_ = 0UL;
				gsize _tmp22_ = 0UL;
				gboolean _tmp23_ = FALSE;
				gboolean _tmp24_ = FALSE;
				guint8* _tmp34_ = NULL;
				gsize _tmp35_ = 0UL;
				gint match_line = 0;
				GeditFindInFilesPluginBookmark _tmp36_ = {0};
				gint _tmp37_ = 0;
				gint _tmp38_ = 0;
				gint _tmp39_ = 0;
				gint _tmp48_ = 0;
				GeditFindInFilesPluginRange _tmp49_ = {0};
				gsize _tmp50_ = 0UL;
				if (!_tmp14_) {
				}
				_tmp14_ = FALSE;
				_tmp15_ = buffer_pos;
				_tmp16_ = buffer_size;
				if (!(_tmp15_ < _tmp16_)) {
					break;
				}
				_tmp17_ = self->priv->cancellable;
				_tmp18_ = g_cancellable_is_cancelled (_tmp17_);
				if (_tmp18_) {
					break;
				}
				_tmp19_ = self->priv->matcher;
				_tmp20_ = buffer;
				_tmp21_ = buffer_size;
				_tmp22_ = buffer_pos;
				_tmp23_ = gedit_find_in_files_plugin_imatcher_has_match (_tmp19_, _tmp20_, _tmp21_, _tmp22_, &match);
				if (!_tmp23_) {
					break;
				}
				_tmp24_ = self->match_whole_word;
				if (_tmp24_) {
					guint8* _tmp25_ = NULL;
					gsize _tmp26_ = 0UL;
					GeditFindInFilesPluginRange _tmp27_ = {0};
					gsize _tmp28_ = 0UL;
					GeditFindInFilesPluginRange _tmp29_ = {0};
					gsize _tmp30_ = 0UL;
					gboolean _tmp31_ = FALSE;
					_tmp25_ = buffer;
					_tmp26_ = buffer_size;
					_tmp27_ = match;
					_tmp28_ = _tmp27_.from;
					_tmp29_ = match;
					_tmp30_ = _tmp29_.to;
					_tmp31_ = gedit_find_in_files_plugin_find_job_is_word_boundary (self, _tmp25_, _tmp26_, (gsize) ((gint) _tmp28_), (gsize) ((gint) _tmp30_));
					if (!_tmp31_) {
						GeditFindInFilesPluginRange _tmp32_ = {0};
						gsize _tmp33_ = 0UL;
						_tmp32_ = match;
						_tmp33_ = _tmp32_.to;
						buffer_pos = _tmp33_;
						continue;
					}
				}
				_tmp34_ = buffer;
				_tmp35_ = buffer_size;
				gedit_find_in_files_plugin_find_job_get_line (self, _tmp34_, _tmp35_, &match, &bookmark);
				_tmp36_ = bookmark;
				_tmp37_ = _tmp36_.line_number;
				match_line = 1 + _tmp37_;
				_tmp38_ = last_line;
				_tmp39_ = match_line;
				if (_tmp38_ != _tmp39_) {
					GeditFindInFilesPluginResult res = {0};
					const gchar* _tmp40_ = NULL;
					gchar* _tmp41_ = NULL;
					gint _tmp42_ = 0;
					guint8* _tmp43_ = NULL;
					GeditFindInFilesPluginRange _tmp44_ = {0};
					gchar* _tmp45_ = NULL;
					GeditFindInFilesPluginResult _tmp46_ = {0};
					GeditFindInFilesPluginResult _tmp47_ = {0};
					_tmp40_ = path;
					_tmp41_ = g_strdup (_tmp40_);
					_tmp42_ = match_line;
					_tmp43_ = buffer;
					_tmp44_ = match;
					_tmp45_ = gedit_find_in_files_plugin_find_job_extract_context (self, _tmp43_, &_tmp44_);
					_g_free0 (_tmp46_.path);
					_tmp46_.path = _tmp41_;
					_tmp46_.line = (gsize) _tmp42_;
					_g_free0 (_tmp46_.context);
					_tmp46_.context = _tmp45_;
					res = _tmp46_;
					_tmp47_ = res;
					g_signal_emit_by_name (self, "on-match-found", &_tmp47_);
					gedit_find_in_files_plugin_result_destroy (&res);
				}
				_tmp48_ = match_line;
				last_line = _tmp48_;
				_tmp49_ = match;
				_tmp50_ = _tmp49_.to;
				buffer_pos = _tmp50_;
			}
		}
	}
	_g_mapped_file_unref0 (file);
}


const gchar* gedit_find_in_files_plugin_find_job_get_needle (GeditFindInFilesPluginFindJob* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_needle;
	result = _tmp0_;
	return result;
}


static void gedit_find_in_files_plugin_find_job_set_needle (GeditFindInFilesPluginFindJob* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_needle);
	self->priv->_needle = _tmp1_;
}


static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}


static void gedit_find_in_files_plugin_value_find_job_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gedit_find_in_files_plugin_value_find_job_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gedit_find_in_files_plugin_find_job_unref (value->data[0].v_pointer);
	}
}


static void gedit_find_in_files_plugin_value_find_job_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gedit_find_in_files_plugin_find_job_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gedit_find_in_files_plugin_value_find_job_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gedit_find_in_files_plugin_value_find_job_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GeditFindInFilesPluginFindJob* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gedit_find_in_files_plugin_find_job_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gedit_find_in_files_plugin_value_find_job_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GeditFindInFilesPluginFindJob** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gedit_find_in_files_plugin_find_job_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* gedit_find_in_files_plugin_param_spec_find_job (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GeditFindInFilesPluginParamSpecFindJob* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer gedit_find_in_files_plugin_value_get_find_job (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB), NULL);
	return value->data[0].v_pointer;
}


void gedit_find_in_files_plugin_value_set_find_job (GValue* value, gpointer v_object) {
	GeditFindInFilesPluginFindJob* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gedit_find_in_files_plugin_find_job_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gedit_find_in_files_plugin_find_job_unref (old);
	}
}


void gedit_find_in_files_plugin_value_take_find_job (GValue* value, gpointer v_object) {
	GeditFindInFilesPluginFindJob* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gedit_find_in_files_plugin_find_job_unref (old);
	}
}


static void gedit_find_in_files_plugin_find_job_class_init (GeditFindInFilesPluginFindJobClass * klass) {
	gedit_find_in_files_plugin_find_job_parent_class = g_type_class_peek_parent (klass);
	((GeditFindInFilesPluginFindJobClass *) klass)->finalize = gedit_find_in_files_plugin_find_job_finalize;
	g_type_class_add_private (klass, sizeof (GeditFindInFilesPluginFindJobPrivate));
	g_signal_new ("on_match_found", GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_RESULT);
	g_signal_new ("on_search_finished", GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void gedit_find_in_files_plugin_find_job_instance_init (GeditFindInFilesPluginFindJob * self) {
	GAsyncQueue* _tmp0_ = NULL;
	self->priv = GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_PRIVATE (self);
	_tmp0_ = g_async_queue_new_full (_g_free0_);
	self->priv->scan_queue = _tmp0_;
	g_rec_mutex_init (&self->priv->__lock_running_workers);
	self->priv->running_workers = (guint) 0;
	self->priv->matcher = NULL;
	self->ref_count = 1;
}


static void gedit_find_in_files_plugin_find_job_finalize (GeditFindInFilesPluginFindJob* obj) {
	GeditFindInFilesPluginFindJob * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJob);
	g_signal_handlers_destroy (self);
	_g_async_queue_unref0 (self->priv->scan_queue);
	__g_list_free__g_thread_unref0_0 (self->priv->thread_workers);
	g_rec_mutex_clear (&self->priv->__lock_running_workers);
	_g_object_unref0 (self->priv->matcher);
	_g_object_unref0 (self->priv->cancellable);
	_g_free0 (self->priv->_needle);
}


GType gedit_find_in_files_plugin_find_job_get_type (void) {
	return gedit_find_in_files_plugin_find_job_type_id;
}


GType gedit_find_in_files_plugin_find_job_register_type (GTypeModule * module) {
	static const GTypeValueTable g_define_type_value_table = { gedit_find_in_files_plugin_value_find_job_init, gedit_find_in_files_plugin_value_find_job_free_value, gedit_find_in_files_plugin_value_find_job_copy_value, gedit_find_in_files_plugin_value_find_job_peek_pointer, "p", gedit_find_in_files_plugin_value_find_job_collect_value, "p", gedit_find_in_files_plugin_value_find_job_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (GeditFindInFilesPluginFindJobClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gedit_find_in_files_plugin_find_job_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeditFindInFilesPluginFindJob), 0, (GInstanceInitFunc) gedit_find_in_files_plugin_find_job_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	gedit_find_in_files_plugin_find_job_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeditFindInFilesPluginFindJob", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return gedit_find_in_files_plugin_find_job_type_id;
}


gpointer gedit_find_in_files_plugin_find_job_ref (gpointer instance) {
	GeditFindInFilesPluginFindJob* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gedit_find_in_files_plugin_find_job_unref (gpointer instance) {
	GeditFindInFilesPluginFindJob* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



